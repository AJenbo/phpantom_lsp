use std::collections::HashMap;
use std::fs;
/// Composer autoload support.
///
/// This module handles parsing `composer.json` to extract PSR-4 autoload
/// mappings, and resolving fully-qualified PHP class names to file paths
/// on disk using those mappings.
///
/// It also parses `autoload_files.php` (generated by Composer) to discover
/// files that contain global function and constant definitions.
///
/// # PSR-4 Resolution
///
/// Given a mapping like `"Klarna\\" => "src/Klarna/"`, a class name like
/// `Klarna\Customer` is resolved by:
///   1. Stripping the matching prefix (`Klarna\`) from the class name
///   2. Converting remaining namespace separators to directory separators
///   3. Appending `.php`
///   4. Prepending the mapped base directory
///
/// Result: `<workspace>/src/Klarna/Customer.php`
use std::path::{Path, PathBuf};

/// A single PSR-4 namespace-to-directory mapping.
#[derive(Debug, Clone)]
pub struct Psr4Mapping {
    /// The namespace prefix, always ending with `\` (e.g. `"Klarna\"`).
    pub prefix: String,
    /// The base directory path relative to the workspace root (e.g. `"src/Klarna/"`).
    pub base_path: String,
}

/// Parse a `composer.json` file at the given workspace root and extract all
/// PSR-4 autoload mappings from both `autoload` and `autoload-dev` sections.
///
/// Returns an empty `Vec` if the file doesn't exist, can't be read, or
/// contains no PSR-4 mappings.
pub fn parse_composer_json(workspace_root: &Path) -> Vec<Psr4Mapping> {
    let composer_path = workspace_root.join("composer.json");
    let content = match fs::read_to_string(&composer_path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };

    let json: serde_json::Value = match serde_json::from_str(&content) {
        Ok(v) => v,
        Err(_) => return Vec::new(),
    };

    let vendor_dir = get_vendor_dir(&json);

    let mut mappings = Vec::new();

    // Extract from both "autoload" and "autoload-dev" sections
    for section_key in &["autoload", "autoload-dev"] {
        if let Some(section) = json.get(section_key)
            && let Some(psr4) = section.get("psr-4")
            && let Some(psr4_obj) = psr4.as_object()
        {
            for (prefix, paths) in psr4_obj {
                extract_psr4_entries(prefix, paths, &mut mappings);
            }
        }
    }

    // Also load vendor autoload mappings (from composer install output)
    let vendor_mappings = parse_vendor_autoload_psr4(workspace_root, &vendor_dir);
    mappings.extend(vendor_mappings);

    // Sort by prefix length descending so longest-prefix-first matching works
    mappings.sort_by(|a, b| b.prefix.len().cmp(&a.prefix.len()));

    mappings
}

/// Read the configured vendor directory from a parsed `composer.json` value.
///
/// Looks at `config.vendor-dir`; defaults to `"vendor"` when absent.
fn get_vendor_dir(composer_json: &serde_json::Value) -> String {
    composer_json
        .get("config")
        .and_then(|c| c.get("vendor-dir"))
        .and_then(|v| v.as_str())
        .map(|s| s.trim_end_matches('/').to_string())
        .unwrap_or_else(|| "vendor".to_string())
}

/// Parse `<vendor>/composer/autoload_psr4.php` and return PSR-4 mappings.
///
/// This file is generated by `composer install` / `composer dump-autoload`.
/// If the file does not exist (e.g. composer install has not been run) an
/// empty `Vec` is returned — the absence is silently tolerated.
///
/// The file contains lines like:
/// ```text
///     'Namespace\\' => array($vendorDir . '/org/pkg/src'),
///     'Other\\' => array($baseDir . '/lib'),
/// ```
///
/// `$vendorDir` is resolved to `<vendor_dir>` (relative to workspace root).
/// `$baseDir` is resolved to the workspace root (i.e. paths are kept relative).
pub fn parse_vendor_autoload_psr4(workspace_root: &Path, vendor_dir: &str) -> Vec<Psr4Mapping> {
    let autoload_path = workspace_root
        .join(vendor_dir)
        .join("composer")
        .join("autoload_psr4.php");

    let content = match fs::read_to_string(&autoload_path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };

    let mut mappings = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Match lines of the form:  'Prefix\\' => array(...),
        if let Some(rest) = trimmed.strip_prefix('\'')
            && let Some(arrow_pos) = rest.find("' => array(")
        {
            // Unescape PHP single-quoted string escapes:
            //   \\  →  \
            //   \'  →  '
            let prefix_raw = rest[..arrow_pos]
                .replace("\\\\'", "'")
                .replace("\\\\", "\\");
            let array_start = arrow_pos + "' => array(".len();

            // Find the closing paren
            let array_content = if let Some(end) = rest[array_start..].rfind(')') {
                &rest[array_start..array_start + end]
            } else {
                continue;
            };

            // Normalise the namespace prefix
            let normalised_prefix = if prefix_raw.ends_with('\\') {
                prefix_raw.clone()
            } else if prefix_raw.is_empty() {
                String::new()
            } else {
                format!("{}\\", prefix_raw)
            };

            // Parse each path entry in the array, separated by commas.
            // Entries look like:  $vendorDir . '/org/pkg/src'
            //                 or: $baseDir . '/lib'
            for entry in array_content.split(',') {
                let entry = entry.trim();
                if let Some(base_path) = resolve_autoload_path_entry(entry, vendor_dir) {
                    mappings.push(Psr4Mapping {
                        prefix: normalised_prefix.clone(),
                        base_path: normalise_path(&base_path),
                    });
                }
            }
        }
    }

    mappings
}

/// Parse `<vendor>/composer/autoload_classmap.php` and return a mapping
/// from fully-qualified class name to file path (relative to the workspace
/// root).
///
/// This file is generated by `composer install` / `composer dump-autoload`
/// and maps class names directly to their defining files.  When the user
/// runs `composer install -o` (optimised autoloader), Composer converts
/// all PSR-0 and PSR-4 mappings into a classmap, giving us complete
/// coverage of every loadable class.
///
/// The file contains lines like:
/// ```text
///     'AWS\\CRT\\Auth\\AwsCredentials' => $vendorDir . '/aws/aws-crt-php/src/AWS/CRT/Auth/AwsCredentials.php',
///     'App\\Models\\User' => $baseDir . '/app/Models/User.php',
/// ```
///
/// `$vendorDir` is resolved relative to the workspace root using the
/// configured vendor directory.  `$baseDir` is the workspace root itself.
///
/// Returns an empty `HashMap` if the file does not exist or cannot be
/// parsed.
pub fn parse_autoload_classmap(
    workspace_root: &Path,
    vendor_dir: &str,
) -> HashMap<String, PathBuf> {
    let autoload_path = workspace_root
        .join(vendor_dir)
        .join("composer")
        .join("autoload_classmap.php");

    let content = match fs::read_to_string(&autoload_path) {
        Ok(c) => c,
        Err(_) => return HashMap::new(),
    };

    let mut classmap = HashMap::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Match lines of the form:
        //   'Fully\\Qualified\\ClassName' => $vendorDir . '/path/to/File.php',
        //   'Fully\\Qualified\\ClassName' => $baseDir . '/path/to/File.php',
        if let Some(rest) = trimmed.strip_prefix('\'')
            && let Some(arrow_pos) = rest.find("' => ")
        {
            // Unescape PHP single-quoted string escapes:
            //   \\  →  \
            //   \'  →  '
            let class_name = rest[..arrow_pos]
                .replace("\\\\'", "'")
                .replace("\\\\", "\\");

            let rhs = rest[arrow_pos + "' => ".len()..]
                .trim()
                .trim_end_matches(',');

            if let Some(relative_path) = resolve_autoload_path_entry(rhs, vendor_dir) {
                classmap.insert(class_name, workspace_root.join(&relative_path));
            }
        }
    }

    classmap
}

/// Resolve a single path entry from `autoload_psr4.php`.
///
/// Handles `$vendorDir . '/path'` and `$baseDir . '/path'`.
fn resolve_autoload_path_entry(entry: &str, vendor_dir: &str) -> Option<String> {
    let entry = entry.trim();

    if let Some(rest) = entry.strip_prefix("$vendorDir . '") {
        // $vendorDir . '/org/pkg/src'
        let path = rest.strip_suffix('\'')?;
        let path = path.strip_prefix('/').unwrap_or(path);
        Some(format!("{}/{}", vendor_dir, path))
    } else if let Some(rest) = entry.strip_prefix("$baseDir . '") {
        // $baseDir . '/lib'
        let path = rest.strip_suffix('\'')?;
        let path = path.strip_prefix('/').unwrap_or(path);
        Some(path.to_string())
    } else {
        None
    }
}

/// Parse `<vendor>/composer/autoload_files.php` and return the resolved
/// file paths.
///
/// This file is generated by `composer install` / `composer dump-autoload`
/// and lists files that should be eagerly loaded — typically containing
/// global function definitions, `define()` calls, and similar bootstrap
/// code.
///
/// The file contains lines like:
/// ```text
///     'hash' => $vendorDir . '/org/pkg/src/functions.php',
///     'hash' => $baseDir . '/app/Http/helpers.php',
/// ```
///
/// `$vendorDir` is resolved relative to the workspace root using the
/// configured vendor directory.  `$baseDir` is the workspace root itself.
///
/// Returns an empty `Vec` if the file does not exist or cannot be parsed.
pub fn parse_autoload_files(workspace_root: &Path, vendor_dir: &str) -> Vec<PathBuf> {
    let autoload_path = workspace_root
        .join(vendor_dir)
        .join("composer")
        .join("autoload_files.php");

    let content = match fs::read_to_string(&autoload_path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };

    let mut files = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Match lines of the form:  'hash' => $vendorDir . '/path/to/file.php',
        //                       or: 'hash' => $baseDir . '/path/to/file.php',
        // We look for `=> $vendorDir` or `=> $baseDir` after the hash key.
        if let Some(arrow_pos) = trimmed.find("=> ") {
            let rhs = trimmed[arrow_pos + 3..].trim().trim_end_matches(',');

            if let Some(base_path) = resolve_autoload_path_entry(rhs, vendor_dir) {
                let full_path = workspace_root.join(&base_path);
                if full_path.is_file() {
                    files.push(full_path);
                }
            }
        }
    }

    files
}

/// Extract PSR-4 entries from a single prefix → path(s) pair.
///
/// The value can be either a string (`"src/"`) or an array of strings
/// (`["src/", "lib/"]`).
fn extract_psr4_entries(prefix: &str, paths: &serde_json::Value, mappings: &mut Vec<Psr4Mapping>) {
    // Normalise the prefix: ensure it ends with `\`
    let normalised_prefix = if prefix.ends_with('\\') {
        prefix.to_string()
    } else if prefix.is_empty() {
        // Empty prefix means "fallback" / root namespace
        String::new()
    } else {
        format!("{}\\", prefix)
    };

    match paths {
        serde_json::Value::String(path) => {
            mappings.push(Psr4Mapping {
                prefix: normalised_prefix.clone(),
                base_path: normalise_path(path),
            });
        }
        serde_json::Value::Array(arr) => {
            for entry in arr {
                if let Some(path) = entry.as_str() {
                    mappings.push(Psr4Mapping {
                        prefix: normalised_prefix.clone(),
                        base_path: normalise_path(path),
                    });
                }
            }
        }
        _ => {}
    }
}

/// Normalise a directory path: ensure it uses forward slashes and ends with `/`.
pub fn normalise_path(path: &str) -> String {
    let p = path.replace('\\', "/");
    if p.ends_with('/') || p.is_empty() {
        p
    } else {
        format!("{}/", p)
    }
}

/// Resolve a fully-qualified PHP class name to a file path using PSR-4 mappings.
///
/// The `class_name` should be the namespace-qualified name (e.g.
/// `"Klarna\\Customer"` or `"Klarna\\Rest\\Order"`). A leading `\` is
/// stripped if present (PHP fully-qualified syntax).
///
/// Returns the first path that exists on disk, or `None` if no mapping
/// matches or the resolved file doesn't exist.
pub fn resolve_class_path(
    mappings: &[Psr4Mapping],
    workspace_root: &Path,
    class_name: &str,
) -> Option<PathBuf> {
    // Strip leading `\` (PHP fully-qualified name syntax)
    let name = class_name.strip_prefix('\\').unwrap_or(class_name);

    // Skip built-in type keywords that are never real classes
    if is_builtin_type(name) {
        return None;
    }

    // Try each mapping (already sorted longest-prefix-first)
    for mapping in mappings {
        let relative = if mapping.prefix.is_empty() {
            // Empty prefix matches everything (root namespace fallback)
            Some(name)
        } else {
            name.strip_prefix(&mapping.prefix)
        };

        if let Some(relative_class) = relative {
            // Convert namespace separators to directory separators
            let relative_path = relative_class.replace('\\', "/");
            let file_path = workspace_root
                .join(&mapping.base_path)
                .join(format!("{}.php", relative_path));

            if file_path.is_file() {
                return Some(file_path);
            }
        }
    }

    None
}

/// Check if a name is a PHP built-in type (not a class).
fn is_builtin_type(name: &str) -> bool {
    matches!(
        name,
        "$this"
            | "self"
            | "static"
            | "parent"
            | "string"
            | "int"
            | "float"
            | "bool"
            | "array"
            | "object"
            | "mixed"
            | "void"
            | "never"
            | "null"
            | "true"
            | "false"
            | "callable"
            | "iterable"
    )
}
